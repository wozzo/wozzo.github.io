<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<link rel="self" href="https://wbates.net/" />
	<id>https://wbates.net/</id>
	<title>Warren Bates</title>
	<rights>2017</rights>
	<updated>2017-08-26T18:03:39Z</updated>
	<subtitle>Warren Bates</subtitle>
	<entry>
		<link href="https://wbates.net/posts/getting-started-with-cake-recipe" />
		<id>https://wbates.net/posts/getting-started-with-cake-recipe</id>
		<title>Getting Started with Cake.Recipe</title>
		<updated>2017-08-26T00:00:00Z</updated>
		<content>&lt;p&gt;I've been playing around with the Cake build tool for a little while now, but having recently had need of a plugin that didn't yet exist I embarked on a journey that lead me to Cake.Recipe.&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;Cake.Recipe is a set of convention based Cake scripts.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If you check out the Content folder in that repository you'll find a host of pre-written cake scripts that cover a wide range of use cases. They've been designed so that they all work together and can be called through a single cake file that contains a few bits of setup. They're used by most of the addin's under the cake-contrib team. The only thing that was lacking at the start of this journey was documentation about how to use Cake.Recipe, which is why I'm writing this post.&lt;/p&gt;
&lt;h1 id="getting-started"&gt;Getting started&lt;/h1&gt;
&lt;p&gt;Before I knew what Cake.Recipe was I was looking around various repositories looking for good ideas for how to improve the addin I was working on at the time (Cake.Bower), and I started to notice that several of the repositories were missing a build.cake file. The .cake file can of course be called whatever you like, but by default it is called build.cake, so for this to be missing, or rather called setup.cake, I found a bit odd.
Looking into the setup.cake file I found something very different from what I'm used to seeing in build.cake files.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;#load nuget:https://www.myget.org/F/cake-contrib/api/v2?package=Cake.Recipe&amp;amp;prerelease
 
Environment.SetVariableNames();
 
BuildParameters.SetParameters(context: Context,
                            buildSystem: BuildSystem,
                            sourceDirectoryPath: "./",
                            title: "Cake.Bower",
                            repositoryOwner: "cake-contrib",
                            repositoryName: "Cake.Bower",
                            appVeyorAccountName: "cakecontrib");
 
BuildParameters.PrintParameters(Context);
 
ToolSettings.SetToolSettings(context: Context,
                            dupFinderExcludePattern: new string[] {
                                BuildParameters.RootDirectoryPath + "/src/Cake.Bower.Tests/*.cs" },
                            testCoverageFilter: "+[*]* -[xunit.*]* -[Cake.Core]* -[Cake.Testing]* -[*.Tests]* ",
                            testCoverageExcludeByAttribute: "*.ExcludeFromCodeCoverage*",
                            testCoverageExcludeByFile: "*/*Designer.cs;*/*.g.cs;*/*.g.i.cs");
Build.Run();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;No tasks. None at all.&lt;/p&gt;
&lt;p&gt;The top line is the critical one. It fetches the Cake.Recipe scripts and loads each one providing the methods you can see being used here. The bootstrapped build.ps1 that you'd normally download if you followed the instructions on the "Setting up a new project" tutorial page has been modified to use a default file of setup.cake purely as a convention to distinguish between normal cake builds and recipe builds. You can then modify the parameters in the setup.cake file to achieve the desired result. There are close to 80 different parameters that can be set here that can be used to configure the ~40 odd tasks that cake.recipe provides.&lt;/p&gt;
&lt;h1 id="parameters"&gt;Parameters&lt;/h1&gt;
&lt;p&gt;Take a look at the parameters.cake file to see what options are available to you out of the box. These can all be set either in the SetParameters or using environment variables.
Tasks
The tasks.cake file paradoxically doesn't contain any tasks, but does give you a handy list of tasks that are configured. It also provides you with the first way of overriding cake.recipe functionality by changing the value assigned to these properties, should one of the tasks need tweaking to suit your needs. More on that in a bit.
The tasks are set in a cake file specific to the purpose of the task, i.e. the tasks related to testing are all in testing.cake, the tasks for code analysis are in analyzing.cake, etc. The best starting point for figuring out what is going is in the build.cake file, currently on line 354&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;BuildParameters.Tasks.DefaultTask = Task("Default")
        .IsDependentOn("Package");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can start to see the intended targets for a full build. Don't get thrown by the lack of dependencies here. For example the Package task target doesn't only depend on the Export-Release-Notes task. Look above the task definition and find the SetupTasks method. In there you can see more dependencies being set.&lt;/p&gt;
&lt;p&gt;This should start to give you an idea what will happen when you run one of the targets listed here. The default is probably the best place to start. If you need a safe project to test it out on, fork Cake.Bower and run .\build.ps1. It will take a while on the first run as it has to download all of the tools and addins required to run.&lt;/p&gt;
&lt;h1 id="cake.bower-build-running"&gt;Cake.Bower build running&lt;/h1&gt;
&lt;p&gt;The tasks that are run by the default target are&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Task                                 Duration
---------------------------------------------------------
Export-Release-Notes                 Skipped
Show-Info                            00:00:00.0093039
Print-AppVeyor-Environment-Variables Skipped
Clean                                00:00:00.0292549
Restore                              00:00:01.0742619
Build                                00:00:05.7580859
DupFinder                            00:00:09.2430267
InspectCode                          00:00:22.4277417
Analyze                              00:00:00.0042806
Install-ReportGenerator              00:00:02.2837979
Install-ReportUnit                   00:00:02.2187105
Install-OpenCover                    00:00:02.2890312
Test-NUnit                           Skipped
Test-xUnit                           00:00:06.9958299
Test-MSTest                          Skipped
Test-VSTest                          Skipped
Test-Fixie                           Skipped
Test                                 00:00:00.0065763
Create-NuGet-Packages                00:00:00.7237132
Create-Chocolatey-Packages           Skipped
Package                              00:00:00.0050486
Default                              00:00:00.0055089
---------------------------------------------------------
Total:                               00:00:53.0741721
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can see some of the tasks were skipped. This means the task appeared in the list of dependencies but the criteria to run it (defined using the &lt;code&gt;WithCriteria&lt;/code&gt; method) were not met. For example the Test-NUnit task will only run if NUnit tests are found. There are none in Cake.Bower so it gets skipped. If I wanted to always skip a step I can find the parameter that governs whether it runs and set it in the setup.cake file. For example if I wanted to disable the InspectCode step I would change my setup.cake's call to BuildParameters.SetParameters to the following.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;BuildParameters.SetParameters(context: Context,
                            buildSystem: BuildSystem,
                            sourceDirectoryPath: "./",
                            title: "Cake.Bower",
                            repositoryOwner: "cake-contrib",
                            repositoryName: "Cake.Bower",
                            appVeyorAccountName: "cakecontrib",
                            shouldRunInspectCode: false);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Run it again and this time the task will be skipped but the rest should be the same.&lt;/p&gt;
&lt;h1 id="replacing-a-task"&gt;Replacing a task&lt;/h1&gt;
&lt;p&gt;With Cake, once a Task has been created you can't create another with the same name. Calling the .Does(...) method adds an additional action but doesn't replace the existing one. If you want to replace the tasks actions with something completely different you first need to clear the existing actions. To clear the InspectCode actions use the following&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;BuildParameters.Tasks.InspectCodeTask.Task.Actions.Clear();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I'm now free to call the .Does(...) method with the action I want it to undertake and be sure it is the only thing it will do, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;BuildParameters.Tasks.InspectCodeTask.Does( () =&amp;gt; Information("And now for something completely different..."));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Running .\build.ps1 now yields the following output when you get to the InspectCode task.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;========================================
InspectCode
========================================
Executing task: InspectCode
And now for something completely different...
Finished executing task: InspectCode
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You are also free to create your own tasks and add them as dependencies to the existing ones. Something like this...&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Task("MakeTea").Does( () =&amp;gt; Information("Make Tea not Love"));
BuildParameters.Tasks.InspectCodeTask.Task.Actions.Clear();
BuildParameters.Tasks.InspectCodeTask
    .IsDependentOn("MakeTea")
    .Does( () =&amp;gt; Information("And now for something completely different..."));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which yields...&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;========================================
MakeTea
========================================
Executing task: MakeTea
Make Tea not Love
Finished executing task: MakeTea
 
========================================
InspectCode
========================================
Executing task: InspectCode
And now for something completely different...
Finished executing task: InspectCode
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And of course if you find that you need loads of additional scripts for a particular use case consider a pull request into Cake.Recipe&lt;/p&gt;</content>
		<summary>Warren Bates</summary>
	</entry>
	<entry>
		<link href="https://wbates.net/posts/this-is-a-test" />
		<id>https://wbates.net/posts/this-is-a-test</id>
		<title>This is a test</title>
		<updated>2017-08-26T00:00:00Z</updated>
		<content>&lt;p&gt;This is a test&lt;/p&gt;</content>
		<summary>Warren Bates</summary>
	</entry>
	<entry>
		<link href="https://wbates.net/posts/setting-up-a-wyam-blog-with-cake-recipe-and-github-pages" />
		<id>https://wbates.net/posts/setting-up-a-wyam-blog-with-cake-recipe-and-github-pages</id>
		<title>Setting up a Wyam blog with Cake.Recipe and GitHub pages</title>
		<updated>2017-08-24T00:00:00Z</updated>
		<content>&lt;p&gt;I first saw &lt;a href="https://wyam.io"&gt;Wyam&lt;/a&gt; in action when I was working on the Cake.Recipe blog series, and was so impressed I decided to move the entire blog to it using GitHub pages to serve it up.
This post is going to document that process for others to follow.
One important distinction to get out of the way is the difference between a personal github page and a project page.&lt;/p&gt;
&lt;p&gt;Personal page url's take the form &lt;code&gt;https://&amp;lt;username&amp;gt;.github.io/&lt;/code&gt; while project pages take the form &lt;code&gt;https://&amp;lt;username&amp;gt;.github.io/&amp;lt;project_name&amp;gt;&lt;/code&gt;. Project pages can be served from any branch in the repository but personal pages can only be served from the master branch. Because of this there will be some slightly different instructions/hacks depending on whether you intend to use this process to create a personal or project page.&lt;/p&gt;
&lt;h1 id="setting-up-the-repositories"&gt;Setting up the repositories&lt;/h1&gt;
&lt;h2 id="personal-pages"&gt;Personal pages&lt;/h2&gt;
&lt;p&gt;Create a repository which matches the pattern &lt;code&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt;, e.g. mine is &lt;a href="https://github.com/wozzo/wozzo.github.io"&gt;wozzo.github.io&lt;/a&gt;. For personal pages the &lt;code&gt;master&lt;/code&gt; branch must be the one that contains the output from the Wyam build. Make a single commit to the &lt;code&gt;master&lt;/code&gt; branch of this empty repository.&lt;/p&gt;
&lt;p&gt;Use the following commands to create a new orphaned branch called &lt;code&gt;develop&lt;/code&gt;. It must be called &lt;code&gt;develop&lt;/code&gt; for cake.recipe to publish the documentation using AppVeyor (remember I mentioned some hacks?).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout --orphan develop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Do an initial commit on this branch too. The majority of our work will be in this &lt;code&gt;develop&lt;/code&gt; branch, while we leave the &lt;code&gt;master&lt;/code&gt; branch to AppVeyor. Use the branch name &lt;code&gt;develop&lt;/code&gt; elsewhere in this tutorial where I use the term "working branch"&lt;/p&gt;
&lt;h2 id="project-pages"&gt;Project pages&lt;/h2&gt;
&lt;p&gt;If a branch exists called &lt;code&gt;gh-pages&lt;/code&gt; then GitHub will use this branch to serve your sites content.
Create a new orphaned branch with the following command&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout --orphan gh-pages
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Do an initial commit on this branch and then switch back to the master branch. Use the branch name &lt;code&gt;master&lt;/code&gt; elsewhere in this tutorial where I use the term "working branch".&lt;/p&gt;
&lt;h1 id="starting-with-wyam"&gt;Starting with Wyam&lt;/h1&gt;
&lt;p&gt;Not strictly a required step, but it might make life easier. Install wyam on your machine - to see how to get Wyam go to their &lt;a href="https://wyam.io/docs/usage/obtaining"&gt;obtaining&lt;/a&gt; page.
Note: I had to add %appdata%/local/wyam to my path to allow powershell to be able to run wyam commands.&lt;/p&gt;
&lt;h1 id="creating-your-blog"&gt;Creating your blog&lt;/h1&gt;
&lt;p&gt;Wyam uses recipes to setup the outline of your site quickly. Create a folder called "docs" in the root of your working branch. In your command line interface of choice browse to the docs folder and run the following command&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wyam new --recipe blog
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will create a new folder called input and setup a couple of pages under there. Follow the next few steps to see what this blog will look like, then we'll start adding some content. The recipe will also add a config.wyam file, but we won't be needing this. It is safe to delete.&lt;/p&gt;
&lt;h1 id="getting-cake.recipe"&gt;Getting Cake.Recipe&lt;/h1&gt;
&lt;p&gt;Go to &lt;a href="https://github.com/cake-contrib/Cake.Recipe"&gt;Cake.Recipe&lt;/a&gt; on GitHub and download the following files to the root of your working branch.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.appveyor.yml&lt;/li&gt;
&lt;li&gt;.gitignore&lt;/li&gt;
&lt;li&gt;build.ps1&lt;/li&gt;
&lt;li&gt;config.wyam&lt;/li&gt;
&lt;li&gt;GitReleaseManager.yaml&lt;/li&gt;
&lt;li&gt;setup.cake&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="setup-cake.recipe"&gt;Setup Cake.Recipe&lt;/h2&gt;
&lt;p&gt;Open up the &lt;code&gt;setup.cake&lt;/code&gt; file in your favourite text editor and edit the parameters so that it reflects the name of your blog.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;BuildParameters.SetParameters(context: Context,
                            buildSystem: BuildSystem,
                            title: "Wozzo.Blog",
                            repositoryOwner: "wozzo",
                            repositoryName: "wozzo.github.io",
                            appVeyorAccountName: "wozzo",
                            wyamRecipe: "Blog",
                            wyamTheme: "CleanBlog");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you're working on a personal page then you may also want to provide an additional parameter to change the virtual directory the website is compiled for. By default Cake will use the &lt;code&gt;repositoryName&lt;/code&gt; value.
For a personal site you add the following parameter.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;webLinkRoot: "/"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I've also added two additional parameters telling Wyam that it should use the blog recipe and Phantom theme.&lt;/p&gt;
&lt;h2 id="setup-appveyors-config"&gt;Setup AppVeyor's config&lt;/h2&gt;
&lt;p&gt;We won't setup AppVeyor just yet, but we can start to get things in place with the &lt;code&gt;.appveyor.yml&lt;/code&gt; config file. Open it up and change the target of the build to &lt;code&gt;Force-Publish-Documentation&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#---------------------------------#
#  Build Script                   #
#---------------------------------#
build_script:
  - ps: .\build.ps1 -Target Force-Publish-Documentation
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you're working on a personal page you should also remove &lt;code&gt;master&lt;/code&gt; from the branch whitelist&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#---------------------------------#
#        Branches to build        #
#---------------------------------#
branches:
  # Whitelist
  only:
    - develop
    - /release/.*/
    - /hotfix/.*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At this point you should make another commit. If you don't have any commits GitVersion will throw an exception when attempting to run the cake build.&lt;/p&gt;
&lt;h1 id="previewing-the-site-locally"&gt;Previewing the site locally&lt;/h1&gt;
&lt;p&gt;Time to see what it looks like. The cake.recipe Wyam script comes with a Preview task which will fire up a local web server, and run wyam with a watch on your files. This means you can view the site in your browser, edit your posts and the browser will refressh so you can see your changes immediately.&lt;/p&gt;
&lt;p&gt;Run the following command in the root of your repository.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.\build.ps1 -target preview
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first run may take a while as it is going to get all the tools it requires, future runs should be much faster.
Look at the end of the build log and you should find a message like the following&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Preview server listening on port 5080 and serving from path file:///.../wozzo
.blog/BuildArtifacts/Documentation with virtual directory Wozzo.Blog and LiveReload support
Watching paths(s) file:///.../content, theme, input
Watching configuration file file:///.../wozzo.blog/config.wyam
Hit any key to exit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The key parts are the port and virtual directory. For personal sites there will be no virtual directory. Replace them in the following url in your browser.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://localhost:&amp;lt;port&amp;gt;/&amp;lt;virtual_directory&amp;gt;/

# Example
http://localhost:5080/Wozzo.Blog
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The virtual directory is case sensitive by the way ;-)&lt;/p&gt;
&lt;p&gt;&lt;img src="../assets/images/wyam-in-browser.png" class="img-fluid" alt="Wyam blog in the browser inception"&gt;&lt;/p&gt;
&lt;p&gt;Isn't it pretty. For some reason when I tried to use the SolidState theme I got exceptions due to missing files. If you get it working, please get in touch.&lt;/p&gt;
&lt;h1 id="appveyor"&gt;AppVeyor&lt;/h1&gt;
&lt;p&gt;Wyam's site has some really great &lt;a href="https://wyam.io/docs/deployment/appveyor"&gt;instructions for setting up Wyam with AppVeyor&lt;/a&gt;, and it's worth looking through but we're going to do things differently to get the benefits of working with Cake.Recipe.&lt;/p&gt;
&lt;p&gt;Cake.Recipe has everything setup with either parameters, or Environment variables. The credentials and settings for most of what we'll need is done through environment variables.
Log in to AppVeyor and add a new project, select your repository. If doing a personal site then change the default branch to &lt;code&gt;develop&lt;/code&gt; on the project settings page.
Go to the project settings page and find the Environment section. We'll need to add three variables here for Cake.Recipe to be able to deploy our site.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Url of the git repository
WYAM_DEPLOY_REMOTE   =   https://github.com/wozzo/wozzo.github.io
# Branch to deploy the site too
WYAM_DEPLOY_BRANCH   =   master / gh-pages
# GitHub personal access token
WYAM_ACCESS_TOKEN    =   **************************************
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The access token must be kept secret. You can create one by following these &lt;a href="https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/"&gt;instructions&lt;/a&gt;. This token will need the repo -&amp;gt; public_repo scope.&lt;/p&gt;
&lt;p&gt;&lt;img src="../assets/images/appveyor-environment-variables.png" class="img-fluid" alt="Setting AppVeyor environment variables"&gt;&lt;/p&gt;
&lt;h1 id="get-blogging"&gt;Get Blogging&lt;/h1&gt;
&lt;p&gt;That's all the setup complete. Now commit any uncommitted changes and push your working branch to the remote. AppVeyor should pick it up and run it deploying your site.&lt;/p&gt;
&lt;p&gt;If there are any problems check the AppVeyor build log. In particular the &lt;code&gt;Printing Build Parameters...&lt;/code&gt; section can provide useful insight.&lt;/p&gt;</content>
		<summary>Warren Bates</summary>
	</entry>
	<entry>
		<link href="https://wbates.net/posts/baking-a-cake-adding-part-2-testing" />
		<id>https://wbates.net/posts/baking-a-cake-adding-part-2-testing</id>
		<title>Testing a Cake Addin</title>
		<updated>2017-08-21T00:00:00Z</updated>
		<content>&lt;p&gt;Tasting the cake would be the obvious pun here, but hopefully by now you've gotten stuck in and had more than a slice. Today I'm going to walkthrough setting up some simple unit tests on the Markdown-Pdf addin I wrote in &lt;a href="http://wbates.net/baking-a-cake-addin/"&gt;part 1&lt;/a&gt;.
In your solution add a new .Net framework class library project. Add the Cake.Testing nuget package to this solution along with your testing framework of choice. I'll be using &lt;a href="https://xunit.github.io/"&gt;xUnit&lt;/a&gt; along with the &lt;a href="https://github.com/shouldly/shouldly"&gt;Shouldly&lt;/a&gt; assertion package.&lt;/p&gt;
&lt;h2 id="fixture"&gt;Fixture&lt;/h2&gt;
&lt;p&gt;Create a new class for your test fixture called MarkdownPdfRunnerFixture. This class should inherit from Cake.Testing's ToolFixture&amp;lt;TSetting&amp;gt; where TSetting is the settings class from the addin that we want to test.
Add a constructor that calls the base constructor passing in a string with the tool's name.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public MarkdownPdfFixture() : base("markdown-pdf") { }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;then add a property which will hold an action for configuring the settings&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public Action&amp;lt;MarkdownPdfRunnerSettings&amp;gt; RunnerSettings;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally add override the RunTool method and use it to instantiate a runner and call its Run method&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;protected override void RunTool()
{
    var tool = new MarkdownPdfRunner(FileSystem, Environment, ProcessRunner, Tools);
    tool.Run(RunnerSettings);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That's the fixture complete. We're going to try various settings out and then call the Run() method on the fixture, which will in turn call the RunTool method we just created and will return a &lt;a href="http://cakebuild.net/api/Cake.Testing.Fixtures/ToolFixtureResult/"&gt;ToolFixtureResult&lt;/a&gt; to us. We'll be able to query this result and check that the correct arguments were sent to the tool.&lt;/p&gt;
&lt;h2 id="tests"&gt;Tests&lt;/h2&gt;
&lt;p&gt;I'm not going to go through each test I'll write for this class. You can check the code &lt;a href="https://github.com/wozzo/Cake_Addin_Blog_Posts/tree/master/Part%202"&gt;here&lt;/a&gt; if you want to see them all. I'll just showcase a couple of examples.
In the first test the configurator is null, so default settings should be used. In this case that means that no arguments are to get passed to the markdown-pdf tool so the Args should be empty.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Fact]
public void No_Settings_Should_Use_Correct_Argument_Provided_In_MarkdownPdfRunnerSettings()
{
    fixture.RunnerSettings = null;
    var result = fixture.Run();
    result.Args.ShouldBe("");
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we use the WithFilePath method and pass in a test string. Because the desired action here is to pass that string as the only argument that's what we check for&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Fact]
public void WithFilePath_Settings_Should_Use_Correct_Argument_Provided_In_MarkdownPdfRunnerSettings()
{
    fixture.RunnerSettings = s =&amp;gt; s.WithFilePath(TestFilePath);
    var result = fixture.Run();
    result.Args.ShouldBe(TestFilePath);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The WithHelp() method should use the --help switch&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Fact]
public void WithHelp_Settings_Should_Use_Correct_Argument_Provided_In_MarkdownPdfRunnerSettings()
{
    fixture.RunnerSettings = s =&amp;gt; s.WithHelp();
    var result = fixture.Run();
    result.Args.ShouldBe("--help");
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally a combination test that checks that all the correct settings are applied and in the correct order.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Fact]
public void WithFilePath_And_CssFilePath_Settings_Should_Use_Correct_Argument_Provided_In_MarkdownPdfRunnerSettings()
{
    fixture.RunnerSettings = s =&amp;gt; s.WithFilePath(TestFilePath).WithCssPath(TestCssFilePath);
    var result = fixture.Run();
    result.Args.ShouldBe($"--css-path {TestCssFilePath} {TestFilePath}");
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="run-the-tests"&gt;Run the tests&lt;/h2&gt;
&lt;p&gt;Hopefully you've added a cake build script to your project by now, in which case you can add the following to it to get cake to run your unit tests as part of a task&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;#tool "xunit.runner.console"
...
var testResultsPath = MakeAbsolute(Directory(artifacts + "./test-results"));
var testAssemblies = new List&amp;lt;FilePath&amp;gt; { MakeAbsolute(File("./src/Cake.Markdown-Pdf.Tests/bin/" + configuration + "/Cake.Markdown-Pdf.Tests.dll")) };

Task("Run-Unit-Tests")
    .IsDependentOn("Build")
    .Does(() =&amp;gt;
{
    CreateDirectory(testResultsPath);

    var settings = new XUnit2Settings {
        XmlReportV1 = true,
        NoAppDomain = true,
        OutputDirectory = testResultsPath,
    };
    settings.ExcludeTrait("Category", "Integration");
    
    XUnit2(testAssemblies, settings);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Happy testing :)&lt;/p&gt;</content>
		<summary>Warren Bates</summary>
	</entry>
	<entry>
		<link href="https://wbates.net/posts/baking-a-cake-addin-part-1" />
		<id>https://wbates.net/posts/baking-a-cake-addin-part-1</id>
		<title>Baking a Cake Addin</title>
		<updated>2017-08-20T00:00:00Z</updated>
		<content>&lt;p&gt;No blog post on Cake is complete without a few puns, and bonus, now while you're googling technical stuff you always get a few recipes for delicious cakes thrown in. So what is cake and why do we need add ins?&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;&lt;a href="https://www.cakebuild.net/"&gt;Cake (C# Make)&lt;/a&gt; is a cross platform build automation system with a C# DSL to do things like compiling code, copy files/folders, running unit tests, compress files and build NuGet packages.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I've recently been switching my organisation from a psake build process to Cake. The psake process had been in place for a long time, but since psake is no longer actively maintained and doesn't support the latest version of Visual Studio we knew we had to move to something different to allow us to use the latest .Net framework and C# language features. Enter Cake. Cake scripts are written in C#, and support using methods from referenced add ins that have been compiled into a dll. As C# developers being able to write our build process in C# is a no brainer right? You still use powershell to compile and run the cake script, but that's all taken care of by the bootstrapped build.ps1 that cake provides. Anyway we're here to talk about cake addins; if you need more information on getting started with cake please visit &lt;a href="https://www.cakebuild.net/docs/tutorials/getting-started"&gt;cakebuild.net&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;At the time of writing there are 166 cake addins available performing a variety of jobs. We're going to write an addin which runs a command line tool available from npm. Based on &lt;a href="https://github.com/cake-contrib/Cake.Npm/issues/16"&gt;this issue&lt;/a&gt; I decided to make a markdown-pdf addin for this walkthrough.&lt;/p&gt;
&lt;p&gt;Start with a new .NET framework class library project in Visual Studio and add the Cake.Core Nuget project.
We're going to start with two classes and an interface which will form the basics of our addin.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;namespace Cake.Markdown_Pdf
{
    public interface IMarkdownPdfRunner
    {
        
    }

    public class MarkdownPdfRunnerSettings : ToolSettings
    {
        
    }

    public class MarkdownPdfRunner : Tool&amp;lt;MarkdownPdfRunnerSettings&amp;gt;, IMarkdownPdfRunner
    {

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The interface will define the commands that can be run from the cake script.
The settings describes the command to be run and will generate the arguments that get passed into it.
The runner will implement the interface as well as helping cake to locate the command we want to run.&lt;/p&gt;
&lt;h2 id="markdownpdfrunner-basics"&gt;MarkdownPdfRunner basics&lt;/h2&gt;
&lt;p&gt;You'll need a constructor that calls the Tool&amp;lt;TSettings&amp;gt; base constructor.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public MarkdownPdfRunner(IFileSystem fileSystem, ICakeEnvironment environment, IProcessRunner processRunner, IToolLocator tools)
    : base(fileSystem, environment, processRunner, tools) { }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then override the GetToolName() method and get it to return a string giving the name of your tool&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;protected override string GetToolName() =&amp;gt; "Markdown-pdf Runner";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Override GetToolExecutableNames(), here is where we provide the names of the files the ToolLocator needs to look for. To find out go to %appdata%\roaming\npm on your machine.&lt;/p&gt;
&lt;p&gt;&lt;img src="../assets/images/finding-npm-commands.png" class="img-fluid" alt="Finding Npm commands"&gt;&lt;/p&gt;
&lt;p&gt;This will usually be the normal command you'd run suffixed with .cmd followed without the suffix&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;protected override IEnumerable&amp;lt;string&amp;gt; GetToolExecutableNames() =&amp;gt; new[] { "markdown-pdf.cmd", "markdown-pdf" };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I'm a big fan of expression bodied methods for these trivial one liners in case you hadn't realised ;)
One final thing to add at this stage is a method that will process the settings and convert them to arguments, or more accurately a &lt;a href="http://cakebuild.net/api/Cake.Core.IO/ProcessArgumentBuilder/"&gt;ProcessArgumentBuilder&lt;/a&gt;
All it will really do is call a method on the settings object that knows how to do that for the specific settings type that we've passed in.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;protected static ProcessArgumentBuilder GetSettingsArguments(MarkdownPdfRunnerSettings settings)
{
    var args = new ProcessArgumentBuilder();
    settings?.Evaluate(args);
    return args;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Put it all together and so far our runner class should look like this. We'll start adding some commands to it shortly.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;    public class MarkdownPdfRunner : Tool&amp;lt;MarkdownPdfRunnerSettings&amp;gt;, IMarkdownPdfRunner
    {
        public MarkdownPdfRunner(IFileSystem fileSystem, ICakeEnvironment environment, IProcessRunner processRunner, IToolLocator tools)
            : base(fileSystem, environment, processRunner, tools) { }

        protected override string GetToolName() =&amp;gt; "Markdown-pdf Runner";

        protected override IEnumerable&amp;lt;string&amp;gt; GetToolExecutableNames() =&amp;gt; new[] { "markdown-pdf.cmd", "markdown-pdf" };

        protected static ProcessArgumentBuilder GetSettingsArguments(MarkdownPdfRunnerSettings settings)
        {
            var args = new ProcessArgumentBuilder();
            settings?.Evaluate(args);
            return args;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="markdownpdfrunnersettings"&gt;MarkdownPdfRunnerSettings&lt;/h2&gt;
&lt;p&gt;This class is going to contain the properties that apply to all the commands we're going to use and the instructions for converting those into command line arguments. Markdown-pdf doesn't have separate "commands" just options so we only need one settings type. See &lt;a href="https://github.com/cake-contrib/Cake.Bower"&gt;Cake.Bower&lt;/a&gt; for an example of a plugin that uses multiple settings types.
We now need to know what options are available to us through markdown-pdf's CLI. Handily this is available &lt;a href="https://www.npmjs.com/package/markdown-pdf#cli-interface"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Usage: markdown-pdf [options] &amp;lt;markdown-file-path&amp;gt;
 
Options:
 
  -h, --help                             output usage information
  -V, --version                          output the version number
  &amp;lt;markdown-file-path&amp;gt;                   Path of the markdown file to convert
  -c, --cwd [path]                       Current working directory
  -p, --phantom-path [path]              Path to phantom binary
  -h, --runnings-path [path]             Path to runnings (header, footer)
  -s, --css-path [path]                  Path to custom CSS file
  -z, --highlight-css-path [path]        Path to custom highlight-CSS file
  -m, --remarkable-options [json]        Options to pass to Remarkable
  -f, --paper-format [format]            'A3', 'A4', 'A5', 'Legal', 'Letter' or 'Tabloid'
  -r, --paper-orientation [orientation]  'portrait' or 'landscape'
  -b, --paper-border [measurement]       Supported dimension units are: 'mm', 'cm', 'in', 'px'
  -d, --render-delay [millis]            Delay before rendering the PDF
  -t, --load-timeout [millis]            Timeout before the page is rendered in case `page.onLoadFinished` isn't fired
  -o, --out [path]                       Path of where to save the PDF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I'm going to add a boolean property for each of the help and version switches, and string/int/enum properties for each of the other values as appropriate, except for the working directory. The working directory is already a property on the ToolSettings we inherited from. Our MarkdownPdfRunnerSettings class should now look like this&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class MarkdownPdfRunnerSettings : ToolSettings
{
    public bool Help { get; set; }
    public bool Version { get; set; }
    public string FilePath { get; set; }
    public string PhantomPath { get; set; }
    public string RunningsPath { get; set; }
    public string CssPath { get; set; }
    public string HighlightCssPath { get; set; }
    public string RemarkableOptions { get; set; }
    public MarkdownPdfPaperFormat PaperFormat { get; set; }
    public MarkdownPdfOrientation Orientation { get; set; }
    public string PaperBorder { get; set; }
    public int RenderDelay { get; set; }
    public int LoadTimeout { get; set; }
    public string OutFilePath { get; set; }
}

public enum MarkdownPdfPaperFormat
{
    None,
    A3,
    A4,
    A5,
    Legal,
    Letter,
    Tabloid
}

public enum MarkdownPdfOrientation
{
    None,
    Portrait,
    Landscape
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I've obviously made some decisions about what type to use to store details about the property, such as an enum for PaperFormat and Orientation and you'll need to make similar decisions when creating your adding depending on what options are available for the tool you're creating an addin for.
We need to add a method that will evaulate these properties and produce our ProcessArgumentBuilder for use in the runner. This is where the evaluate command comes in. Effectively it will query each property and the relevant string to the ProcessArgumentBuilder passed in.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;internal void Evaluate(ProcessArgumentBuilder args)
{
    if (Help)
        args.Append("--help");
    if (Version)
        args.Append("--version");
    if (!string.IsNullOrWhiteSpace(PhantomPath))
        args.Append($"--phantom-path {PhantomPath}");
    if (!string.IsNullOrWhiteSpace(RunningsPath))
        args.Append($"--runnings-path {RunningsPath}");
    if (!string.IsNullOrWhiteSpace(CssPath))
        args.Append($"--css-path {CssPath}");
    if (!string.IsNullOrWhiteSpace(HighlightCssPath))
        args.Append($"--highlight-css-path {HighlightCssPath}");
    if (!string.IsNullOrWhiteSpace(RemarkableOptions))
        args.Append($"--remarkable-options {RemarkableOptions}");
    if (PaperFormat != MarkdownPdfPaperFormat.None)
        args.Append($"--paper-format {PaperFormat}");
    if (Orientation != MarkdownPdfOrientation.None)
        args.Append($"--paper-orientation {Orientation}");
    if (!string.IsNullOrWhiteSpace(PaperBorder))
        args.Append($"--paper-border {PaperBorder}");
    if (RenderDelay &amp;gt; 0)
        args.Append($"--render-delay {RenderDelay}");
    if (LoadTimeout &amp;gt; 0)
        args.Append($"--load-timeout {LoadTimeout}");
    if (!string.IsNullOrWhiteSpace(OutFilePath))
        args.Append(OutFilePath);
    if (!string.IsNullOrWhiteSpace(FilePath))
        args.Append(FilePath);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="setting-properties"&gt;Setting properties&lt;/h2&gt;
&lt;p&gt;I'm going to add a set of fluent extension methods for setting these properties so we can set several of them at once in a single lambda expression.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static class MarkdownPdfRunnerSettingsExtensions
{
    public static MarkdownPdfRunnerSettings UseWorkingDirectory(this MarkdownPdfRunnerSettings settings, DirectoryPath workingDirectory)
    {
        settings.WorkingDirectory = workingDirectory;
        return settings;
    }

    public static MarkdownPdfRunnerSettings WithHelp(this MarkdownPdfRunnerSettings settings)
    {
        settings.Help = true;
        return settings;
    }

    public static MarkdownPdfRunnerSettings WithVersion(this MarkdownPdfRunnerSettings settings)
    {
        settings.Version = true;
        return settings;
    }

    public static MarkdownPdfRunnerSettings WithPhantomPath(this MarkdownPdfRunnerSettings settings, string phantomPath)
    {
        settings.PhantomPath = phantomPath;
        return settings;
    }

    public static MarkdownPdfRunnerSettings WithRunningsPath(this MarkdownPdfRunnerSettings settings, string runningsPath)
    {
        settings.RunningsPath = runningsPath;
        return settings;
    }

    public static MarkdownPdfRunnerSettings WithCssPath(this MarkdownPdfRunnerSettings settings, string cssPath)
    {
        settings.CssPath = cssPath;
        return settings;
    }

    public static MarkdownPdfRunnerSettings WithHighlightCssPath(this MarkdownPdfRunnerSettings settings, string highlightCssPath)
    {
        settings.HighlightCssPath = highlightCssPath;
        return settings;
    }

    public static MarkdownPdfRunnerSettings WithRemarkableOptions(this MarkdownPdfRunnerSettings settings, string remarkableOptions)
    {
        settings.RemarkableOptions = remarkableOptions;
        return settings;
    }

    public static MarkdownPdfRunnerSettings WithPaperFormat(this MarkdownPdfRunnerSettings settings, MarkdownPdfPaperFormat paperFormat)
    {
        settings.PaperFormat = paperFormat;
        return settings;
    }

    public static MarkdownPdfRunnerSettings WithOrientation(this MarkdownPdfRunnerSettings settings, MarkdownPdfOrientation orientation)
    {
        settings.Orientation = orientation;
        return settings;
    }

    public static MarkdownPdfRunnerSettings WithPaperBorder(this MarkdownPdfRunnerSettings settings, string border)
    {
        settings.PaperBorder = border;
        return settings;
    }

    public static MarkdownPdfRunnerSettings WithRenderDelay(this MarkdownPdfRunnerSettings settings, int renderDelay)
    {
        settings.RenderDelay = renderDelay;
        return settings;
    }

    public static MarkdownPdfRunnerSettings WithLoadTimeout(this MarkdownPdfRunnerSettings settings, int loadTimeout)
    {
        settings.LoadTimeout = loadTimeout;
        return settings;
    }

    public static MarkdownPdfRunnerSettings WithFilePath(this MarkdownPdfRunnerSettings settings, string filePath)
    {
        settings.FilePath = filePath;
        return settings;
    }

    public static MarkdownPdfRunnerSettings WithOutFilePath(this MarkdownPdfRunnerSettings settings, string outFilePath)
    {
        settings.OutFilePath = outFilePath;
        return settings;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="commands"&gt;Commands&lt;/h2&gt;
&lt;p&gt;Finally we're going to add the commands to process the settings and run the command line tool.
Add the following two definitions to the interface (again for addins that will require more than one command use Cake.Bower as an example)&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;IMarkdownPdfRunner Run(Action&amp;lt;MarkdownPdfRunnerSettings&amp;gt; configure = null);
IMarkdownPdfRunner Run(MarkdownPdfRunnerSettings settings);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then to the MarkdownPdfRunner class to fill in the implementation
The first method will create a new settings object and run the lambda passed in before passing on the responsibility for execution to the other method.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public IMarkdownPdfRunner Run(Action&amp;lt;MarkdownPdfRunnerSettings&amp;gt; configure = null)
{
    var settings = new MarkdownPdfRunnerSettings();
    configure?.Invoke(settings);
    return Run(settings);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The method accepting a settings object will use our GetSettingsArguments method from earlier to build the ProcessArgumentBuilder and pass that on to the base classes Run method which will run the tool passing in the arguments given&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public IMarkdownPdfRunner Run(MarkdownPdfRunnerSettings settings)
{
    var args = GetSettingsArguments(settings);
    Run(settings, args);
    return this;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The only thing that's missing now (apart from a build script, unit tests, etc.) is the ability to run this from a cake file.
In order to call any of this from cake you need a cake alias.
I'm going to show two different options for this part, one using a CakeMethodAlias and the other a CakePropertyAlias. For this particular addin the CakeMethodAlias is probably the most suitable since there aren't different commands which the markdown-pdf tool accepts, but for something like npm, bower, gulp, etc which have subcommands the property alias approach is the way to go. The difference between the two is that a CakePropertyAlias can't accept arguments.&lt;/p&gt;
&lt;h3 id="cakemethodalias"&gt;CakeMethodAlias&lt;/h3&gt;
&lt;p&gt;Here we'll create a new static class with an ICakeContext extension method. My adding the CakeMethodAlias attribute this method will be available to us from our cake script. This method will instantiate a runner and call its Run method.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static class MarkdownPdfRunnerAliases
{
    [CakeMethodAlias]
    public static IMarkdownPdfRunner MarkdownPdf(this ICakeContext context,
        Action&amp;lt;MarkdownPdfRunnerSettings&amp;gt; configure)
    {
        if (context == null)
            throw new ArgumentNullException(nameof(context));
        var runner = new MarkdownPdfRunner(context.FileSystem, context.Environment, context.ProcessRunner, context.Tools);
        return runner.Run(configure);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This addin is now ready to be used in a cake script as below.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;#reference "./bin/Cake.Markdown-Pdf.dll" // Use the relative path to your Cake.Markdown-Pdf.dll file built by Visual Studio.

var target = Argument("target", "Default");

Task("Default")
  .Does(() =&amp;gt;
{
    MarkdownPdf(s =&amp;gt; s.WithFilePath("README.md"));
});

RunTarget(target);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="cakepropertyalias"&gt;CakePropertyAlias&lt;/h3&gt;
&lt;p&gt;This approach will return a new MarkdownPdfRunner. This exposes all of the public methods on the runner to the cake script through the object, which is why this approach is more useful to addins that have multiple commands (e.g. bower's install, update, and uninstall commands etc.)&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[CakePropertyAlias]
public static IMarkdownPdfRunner MarkdownPdf(this ICakeContext context)
{
    if (context == null)
        throw new ArgumentNullException(nameof(context));
    return new MarkdownPdfRunner(context.FileSystem, context.Environment, context.ProcessRunner, context.Tools);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This changes the call from &lt;code&gt;MarkdownPdf(s =&amp;gt; s.WithFilePath("README.md"));&lt;/code&gt; to &lt;code&gt;MarkdownPdf.Run(s =&amp;gt; s.WithFilePath("README.md"));&lt;/code&gt;
A subtle difference but as stated, important if there's more than one command that needs to be run.&lt;/p&gt;
&lt;h2 id="final-steps"&gt;Final steps&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Check out Cake.Testing for some utilities to help with testing these scripts. I'll write a follow up blog post soon with more details on how to unit test this addin.
Add to nuget, and then you can change the #reference line to #addin and your script will automatically download it when run.&lt;/li&gt;
&lt;li&gt;Setup a cake script for this project.&lt;/li&gt;
&lt;li&gt;Check out &lt;a href="https://github.com/cake-contrib/Home"&gt;Cake-Contrib on Github&lt;/a&gt; and consider adding your addin on there. I started with Cake.Bower, and decided to write this blog post off the back of that.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The resulting addin from this blog post can be found at &lt;a href="https://github.com/wozzo/Cake.Markdown-Pdf"&gt;Wozzo/Cake.Markdown-Pdf on github&lt;/a&gt; and the blog series can be found at &lt;a href="https://github.com/wozzo/Cake_Addin_Blog_Posts"&gt;Wozzo/Cake_Addin_Blog_Posts&lt;/a&gt;&lt;/p&gt;</content>
		<summary>Warren Bates</summary>
	</entry>
	<entry>
		<link href="https://wbates.net/posts/seeding-data-using-entity-framework-in-asp.net-core" />
		<id>https://wbates.net/posts/seeding-data-using-entity-framework-in-asp.net-core</id>
		<title>Seeding data using Entity Framework in ASP.NET Core</title>
		<updated>2016-09-17T00:00:00Z</updated>
		<content>&lt;p&gt;With thanks to &lt;a href="http://coderhints.com/ef7-seed-user/"&gt;coderhints.com&lt;/a&gt; for the initial steps in doing this. I've done a bit of refactoring and added some additional steps to enable setting up a lot of data quickly and easily.&lt;/p&gt;
&lt;p&gt;I'm going to demonstrate how you can set up some default information in your database using Entity Framework, and a default user for your application. Firstly find the ConfigureServices method in the Startup class. This is the first way my approach differs from above; ConfigureServices is where the DbContext is added to the application and it's where it should be setup, while Configure is where you tell the application how to respond to HTTP requests [1]. At the end of this method add the following code.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var serviceProvider = services.BuildServiceProvider();
var dbContext = serviceProvider.GetService&amp;lt;ApplicationDbContext&amp;gt;();
var userManager = serviceProvider.GetService&amp;lt;UserManager&amp;lt;ApplicationUser&amp;gt;&amp;gt;();
var roleManager = serviceProvider.GetService&amp;lt;RoleManager&amp;lt;IdentityRole&amp;gt;&amp;gt;();
dbContext.Database.Migrate();
dbContext.EnsureSeedData(userManager, roleManager).Wait();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The serviceProvider is what allows us to retrieve instances of the services we need, in this case the ApplicationDbContext, UserManager and RoleManager. Calling the migrate method ensures we have applied the latest migrations and are working with an up to date schema. Finally that horrible red line there is the method where we're going to our seeding. So flick over to your ApplicationDbContext class and add a new method with the following signature&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public async Task EnsureSeedData(UserManager&amp;lt;ApplicationUser&amp;gt; userManager, RoleManager&amp;lt;IdentityRole&amp;gt; roleManager)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This method needs to be rerunnable without throwing exceptions for adding repeat items, and nor do you want that, so every call you make that's going to update the database should have a check to make sure that data doesn't already exist.&lt;/p&gt;
&lt;h1 id="adding-a-default-user"&gt;Adding a default user&lt;/h1&gt;
&lt;p&gt;We're going to start by setting up our default 'Administrator' user. To do that we need to have an Administrator role.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Add roles
if (!await Roles.AnyAsync(r =&amp;gt; string.Equals(r.Name, "Administrator", System.StringComparison.OrdinalIgnoreCase)))
    await roleManager.CreateAsync(new IdentityRole("Administrator"));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we check for the roles existence and if it isn't there, we add it. This should be repeated for any roles you require.
Now to create our new user&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Add Admin user
var adminUser = userManager.Users.FirstOrDefault(u =&amp;gt; string.Equals(u.UserName, "admin@wbates.net", System.StringComparison.OrdinalIgnoreCase));
if (adminUser == null)
{
    adminUser = new ApplicationUser
    {
        UserName = "admin@wbates.net",
        Email = "admin@wbates.net"
    };
    var result = await userManager.CreateAsync(adminUser, "AReallyDifficultImpossibleToGuessPassword123#");
    if (result != IdentityResult.Success)
        throw new System.Exception($"Unable to create '{adminUser.UserName}' account: {result}");
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As always, check for the users existence and because we'll be wanting to ensure this user is enabled and has the 'Administrator' role we'll keep a reference to it. It's worth noting that no Exception is normally thrown if the user has not been created, instead the object returned from the CreateAsync call will tell us and give a message if it has failed. The most common reason for this is that the password is not complicated enough, hence the '#' on the password above.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;await userManager.SetLockoutEnabledAsync(adminUser, false);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Well we wouldn't want our administrator to be locked out of the system would we?&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Check AdminUserRoles
var adminRoles = await userManager.GetRolesAsync(adminUser);
if (!adminRoles.Any(r =&amp;gt; string.Equals(r, "Administrator")))
    await userManager.AddToRoleAsync(adminUser, "Administrator");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally we check that the user is in the admin role, and we're done with setting up our default user. Check the previous post for how ASP.NET Core configuration allows us to set some of the above defaults using .json files instead of hard coding them as we have here.&lt;/p&gt;
&lt;h1 id="adding-seed-data"&gt;Adding seed data&lt;/h1&gt;
&lt;p&gt;Assuming you've added additional DbSets to your ApplicationDbContext for your models, they'll be available in the EnsureSeedData method. As above you'll want to check for each values existing before adding it, but otherwise create an instance of the model and .Add it to the relevant DbSet. The changes won't be saved until you call SaveChangesAsync and it has completed, so leave that until the end. Here's a quick sample that shows how to add some records and save the changes to finish.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Ensure default MediaTypes
if (!MediaTypes.Any(t =&amp;gt; string.Equals(t.Name, "DVD", System.StringComparison.OrdinalIgnoreCase)))
{
    var mediaType = new MediaType { Name = "DVD", Description = "Digital Versatile Disc" }
    MediaTypes.Add(mediaType);
}
await SaveChangesAsync();
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="top-tips"&gt;Top tips&lt;/h1&gt;
&lt;p&gt;Use ASP.NET's Configuration Options[2] to describe default values and allow them to be set by using .json files for different environments.
Move most of this additional configuration out to an extension method on the IServicesCollection. Keep the configure method clean.
Define the roles as auto properties in a static class so you don't need to use strings like �Administrator� to reference them everywhere&lt;/p&gt;</content>
		<summary>Warren Bates</summary>
	</entry>
	<entry>
		<link href="https://wbates.net/posts/asp.net-core-configuration" />
		<id>https://wbates.net/posts/asp.net-core-configuration</id>
		<title>ASP.NET Core Configuration</title>
		<updated>2016-04-24T00:00:00Z</updated>
		<content>&lt;p&gt;Only just beginning to dive into ASP.NET Core (or ASP.NET 5 if you prefer), but there's a great deal to like. Configuration in Core is extremely simple. Values can simply be added to a json (or other format, but why bother) configuration file and are then available to your application where Configuration is instantiated.
The default projects will include the following lines in the Startup method of Startup.cs.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = new ConfigurationBuilder().AddJsonFile("appsettings.json");
Configuration = builder.Build().ReloadOnChanged("appsettings.json");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will load the values from the appsettings.json file (if it exists) into the Configuration property. Multiple calls to this method can be chained together (see environment specific config below). If appsettings.json looked like this&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
    "Logging": {
        "IncludeScopes": false,
        "LogLevel": {
            "Default": "Verbose",
            "System": "Information",
            "Microsoft": "Information"
        }
    },
    "MyConfigValue": "An important configuration string"
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The logging stuff is default, I've added the MyConfigValue key, which means that once Configuration is instantiated I can then access it's value within the Startup class with the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Configuration["MyConfigValue"];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The Logging.LogLevel.Default value can be retrieved using&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Configuration["Logging:LogLevel:Default"];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By creating config classes specific to different areas of your application you can use the built in DI to inject that config only where it's needed.&lt;/p&gt;
&lt;p&gt;If we replace MyConfigValue in the appsettings.json file above with the following key&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;"MyConfig": {
    "Value1": "This is the first config value",
    "Value2": "And this is the second",
    "Number1": 15
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now add a new class to the project which can be called anything but I'm going with MyConfig.cs&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class MyConfig
{
    public string Value1 { get; set; }
    public string Value2 { get; set; }
    public int Number1 { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see the properties match up. We now need to configure the options to be populated into a MyConfig object. Back to startup.cs and find the ConfigureServices method. Add the following lines&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;services.AddOptions();
services.Configure&amp;lt;MyConfig&amp;gt;(Configuration.GetSection("MyConfig");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This takes in the Configuration property and configures it so that when we ask for a MyConfig object it will provide it using whatever it has read from appsettings.json file by matching the classes properties to the keys with the same name. To see that in use create a new controller and add a constructor passing in IOptions as a parameter. This will provide an accessor to a populated config object. which is then accessible in the constructor and can be assigned as a property on that controller.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public MyController(IOptions&amp;lt;MyConfig&amp;gt; myConfig)
{
    _myConfig = myConfig.Value;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The _myConfig object will now contain our config for this section.&lt;/p&gt;
&lt;h1 id="environment-specific-config"&gt;Environment specific config&lt;/h1&gt;
&lt;p&gt;You can easily add additional config files for each environment by calling AddJsonFile on the ConfigurationBuilder multiple times. Since I wrote this the default configure method has the following code.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = new ConfigurationBuilder()
    .SetBasePath(env.ContentRootPath)
    .AddJsonFile("appsettings.json", optional: true, reloadOnChange: true)
    .AddJsonFile($"appsettings.{env.EnvironmentName}.json", optional: true);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The later files take priority over the earlier ones, overwriting any earlier values. See this page for info on how to set the EnvironmentName. I also recommend adding *.development.json to your .gitignore files so that your development environment configuration isn't committed.&lt;/p&gt;</content>
		<summary>Warren Bates</summary>
	</entry>
	<entry>
		<link href="https://wbates.net/posts/configuring-for-pretty-urls-in-angularjs-and-visual-studio" />
		<id>https://wbates.net/posts/configuring-for-pretty-urls-in-angularjs-and-visual-studio</id>
		<title>Configuring for Pretty URLs in AngularJS and Visual Studio</title>
		<updated>2015-06-08T00:00:00Z</updated>
		<content>&lt;p&gt;Pretty URLs look much better than some of the long query string type URLs we've gotten used to.
AngularJS makes it very simple to use pretty urls just follow the steps below and then configure for your server.&lt;/p&gt;
&lt;p&gt;You need to include the ngRoute module with the following line:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;script src="//ajax.googleapis.com/ajax/libs/angularjs/1.2.25/angular-route.js"&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our SPA also needs to know where to put the templates when a sub page is requested. Create a div in your page and add the ng-view attribute. That's it.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;div ng-view&amp;gt;
    &amp;lt;!-- Content will be injected here --&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next you need to add &lt;code&gt;$routeProvider&lt;/code&gt; and &lt;code&gt;$locationProvider&lt;/code&gt; to your config and set them up.
You use the when() function to define which view to serve up depending on what the path is. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;mainApp.config(function ($routeProvider, $locationProvider) {
    // Route for home page
    $routeProvider.when('/', {
        templateUrl: '_home/home.html',
        controller: 'CarouselCtrl'
    })
    .when('/about', {
        templateUrl: '_about/about.html',
        controller: 'aboutCtrl'
    })
    .otherwise({
        redirectTo: "/"
    });
 
    $locationProvider.html5Mode(true);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This means that if I go to &lt;a href="http://yourserver.com/about"&gt;http://yourserver.com/about&lt;/a&gt; the page will serve up the contents of the _about/about.html.
The $locationProvider line is required if you would like to also remove the hash from the URL. Without this your urls will appear like &lt;a href="http://yourserver.com/#/about;"&gt;http://yourserver.com/#/about;&lt;/a&gt; If you aren't worried about the # then you're finished and the following steps will not be necessary. Older browsers will also default back to using the # if they aren't fancy enough for pretty URLs.&lt;/p&gt;
&lt;p&gt;Configuring your webserver to always route back to the index.html file, or whatever you main app's file is, is probably the trickiest aspect of this process. You also need to exclude any folders which actually do exist because otherwise the webserver will route back to index.html when trying to find each of your site assets (css files, images, etc.).&lt;/p&gt;
&lt;h1 id="for-iis-express"&gt;For IIS Express:&lt;/h1&gt;
&lt;p&gt;(See below for IIS Web Core as used in VS)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Download &lt;a href="http://www.iis.net/downloads/microsoft/url-rewrite"&gt;URL Rewrite&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Run IIS Manager (found in the start menu)&lt;/li&gt;
&lt;li&gt;Expand the panel on the left to find your site&lt;/li&gt;
&lt;li&gt;Load URL Rewrite&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src="../assets/images/add-rule.png" class="img-fluid" alt="Add Url Rewrite rule"&gt;&lt;/p&gt;
&lt;ol start="5"&gt;
&lt;li&gt;&lt;p&gt;Click "Add Rule"&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Choose a blank inbound rule
8 Call it Pretty URL Exclusions. These will be the folders that actually exist that you don't want to be rerouted.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Select "does not match the pattern"&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Add in a regular expression to ignore all the folders that exists&lt;/p&gt;
&lt;p&gt;For example:
To ignore the common folder and its contents use &lt;code&gt;common/.*&lt;/code&gt;
Then use the pipe (|) to separate it from another folder
You might end up with something like
&lt;code&gt;css/.*|js/.*|images.*&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For these folders we want the action type to be "None"&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Check "Stop processing of subsequent rules&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Apply the rule&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src="../assets/images/edit-inbound-rule.png" class="img-fluid" alt="Edit inbound url rewrite rule"&gt;&lt;/p&gt;
&lt;ol start="12"&gt;
&lt;li&gt;Create another blank inbound rule&lt;/li&gt;
&lt;li&gt;Call it Pretty URL Redirect.&lt;/li&gt;
&lt;li&gt;Select Matches the pattern and input .* to match all paths&lt;/li&gt;
&lt;li&gt;Choose Redirect as the action type&lt;/li&gt;
&lt;li&gt;Set the url to index.html or your main app file.&lt;/li&gt;
&lt;li&gt;Apply the rule and restart the webserver.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id="for-iis-web-core-visual-studio"&gt;For IIS Web Core (Visual Studio)&lt;/h1&gt;
&lt;p&gt;I found the easiest thing to do here was just add the same rules as above directly into the web.config file in the project.
Open it up and add in the following (edited for your folders ofcourse: see IIS Express above for more details) between your configuration tags.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;system.webServer&amp;gt;
    &amp;lt;rewrite&amp;gt;
        &amp;lt;rules&amp;gt;
            &amp;lt;clear /&amp;gt;
            &amp;lt;rule name="Pretty URL Exclusions" stopProcessing="true"&amp;gt;
                &amp;lt;match url="(css/.*|js/.*|images/.*)" /&amp;gt;
                &amp;lt;conditions logicalGrouping="MatchAll" trackAllCaptures="false" /&amp;gt;
                &amp;lt;action type="None" /&amp;gt;
            &amp;lt;/rule&amp;gt;
            &amp;lt;rule name="Pretty URL Redirect"&amp;gt;
                &amp;lt;match url="(.*)" /&amp;gt;
                &amp;lt;conditions logicalGrouping="MatchAll" trackAllCaptures="false" /&amp;gt;
                &amp;lt;action type="Rewrite" url="index.html" /&amp;gt;          
            &amp;lt;/rule&amp;gt;
        &amp;lt;/rules&amp;gt;
    &amp;lt;/rewrite&amp;gt;
&amp;lt;/system.webServer&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Restart your server and it should take effect straight away.&lt;/p&gt;
&lt;h1 id="apache-web-server"&gt;Apache Web Server&lt;/h1&gt;
&lt;p&gt;Apache is configured using the .htaccess file. It's typically located in the wwwroot folder. Find and open it in your editor of choice. Assuming the mod_rewrite.c is installed add the following lines to the .htaccess file to check if a file exists and if not redirect to the base file as above.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;ifModule mod_rewrite.c&amp;gt;
    RewriteEngine On
    RewriteCond %{REQUEST_FILENAME} !-f
    RewriteCond %{REQUEST_FILENAME} !-d
    RewriteCond %{REQUEST_URI} !index
    RewriteRule (.*) index.html [L]
&amp;lt;/ifModule&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note: If you're doing this on a unix based system it's likely case sensitive so you will need to be very careful that you have typed all of your src tags in correctly. Or you could add the following as well and install the mod_speling.c if necessary.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;IfModule mod_speling.c&amp;gt;
    CheckSpelling On
    CheckCaseOnly On
&amp;lt;/IfModule&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Restart your server and you should be good to go.&lt;/p&gt;
&lt;h1 id="hints"&gt;Hints:&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Add &lt;code&gt;caseInsensitiveMatch: true&lt;/code&gt; to the when functions to remove case sensitivity.&lt;/li&gt;
&lt;li&gt;Check that all of your assets are linked correctly from your index.html file.
For example &lt;code&gt;&amp;lt;link href="Content/nav.css" rel="stylesheet" /&amp;gt;&lt;/code&gt; will not work if you attempted to access one of the "subfolders" because the browser would be looking in that subfolder for the content folder and nav file.
Add a / to the front of the path to solve this problem (took me 20 minutes to figure that one out).
&lt;code&gt;&amp;lt;link href="/Content/nav.css" rel="stylesheet" /&amp;gt;&lt;/code&gt; will work&lt;/li&gt;
&lt;/ol&gt;</content>
		<summary>Warren Bates</summary>
	</entry>
	<entry>
		<link href="https://wbates.net/posts/closures-in-csharp" />
		<id>https://wbates.net/posts/closures-in-csharp</id>
		<title>Closures in C#</title>
		<updated>2015-05-28T00:00:00Z</updated>
		<content>&lt;p&gt;Closures are a vital part of any language that passes functions around as variables. They ensure that everything that was available when we defined the function is available when it's called later, even if it's called in a different scope or long after the original scope has completely ended. There's a vast amount of information available on closures in Javascript because as a classless language where functions are always first class objects closures are regularly used to imitate class like functionality.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;function fakeClass() {
    var publicVar = "This variable will be public";
    this.publicVar = publicVar;
  
    var privateVar = "This variable will be private";
    this.getPrivateVar = function() {
        return privateVar;
    }
}

var instance = new fakeClass();
 
// This will output "This variable will be public"
console.log(instance.publicVar);
// This will output "This variable will be private"
console.log(instance.getPrivateVar());
// This will throw a type undefined error
console.log(instance.privateVar);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above code the publicVar variable is attached to the this object and can be set and read through accessing fakeClass.publicVar. However, the privateVar variable cannot be accessed since it has not been attached to the this object. That is where the getPrivateVar function comes in. The privateVar variable was available at the time the function was defined and so it will be available when the getPrivateVar function is called. The privateVar itself is no longer in scope at the bottom of the example and since it wasn't attached to the this object when we try to access it, we'll get an error.&lt;/p&gt;
&lt;p&gt;This is just an example of how closures can be used and what they do. In C# we obviously have far better ways of declaring private variables, namely the private keyword. That's not to say that closures are suddenly useless in C#, in fact any time we want a function to have data that persists between uses we can use a closure to do so. The alternative would be to create a class that contains properties for all of the data we want to use, but closures are much briefer in terms of how much code is needed.&lt;/p&gt;
&lt;h1 id="prime-generator"&gt;Prime Generator&lt;/h1&gt;
&lt;p&gt;For the Project Euler problems I realised I was needing to copy code between problems and one of the things I was regularly doing was generating prime numbers. Doing so with a normal function would require that I knew how many primes I needed, and could then return an array with all of the primes up to that point. .Net's IEnumerable achieves something very similar to this; closures are just another tool in the box. I like how simple they are to write and use, but sometimes we may need the more advanced functionality of the IEnumerable.
The pseudo code for generating prime numbers looks something like the following, where isPrime(num) is a function which returns a boolean telling us if the num variable passed is a prime number or not (more notes on that at the end).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private int getPrime() {
    int current = 2;
    while (true) {
        if (isPrime(current)) {
            return current;
        }
        current++;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You've possibly already spotted the problem. As soon as a prime is found, which is immediately since we start with a prime, the function will return and the current variable will never get incremented. The next time the function is called the current value will once again be set as 2 and will be returned immediately. Enter the closure.&lt;/p&gt;
&lt;p&gt;What if we could put the while loop into a separate function that incremented the current value? We first need to change the above function so that it returns a delegate function. Making a function a delegate means it can be passed around like a variable in the same way as all functions can be in javascript.&lt;/p&gt;
&lt;p&gt;The function declaration needs to be changed to &lt;code&gt;private Func\&amp;lt;int\&amp;gt; getPrimeGenerator()&lt;/code&gt;. This tells the compiler that we will be expecting the return from this function to be a delegate function which itself has a return type of int. Next we declare and initialise the variable that stores our current position, then we declare the function that will return our primes.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;private Func&amp;lt;int&amp;gt; getPrimes()
{
    int current = 1;
    Func&amp;lt;int&amp;gt; nextPrime = delegate()
    {
        current++;
        while (!isPrime(current))
        {
            current++;
        }
        return current;
    };
    return nextPrime;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The pseudo code has been modified slightly so that the if statement has been implemented with the while loop, but the functionality isn't any different. Each time the delegate function is called it will increment the current variable until a new prime is found and return that. A reference to the current variable has been closed into the delegate function. Let's see how this is used to get the first hundred prime numbers.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var getNextPrime = getPrimes();
for (int i = 0; i &amp;lt; 100; i++) {
    Console.WriteLine(getNextPrime());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That's it. We call the first function and store the returned delegate in another variable, then we call that as many times as we like, each time it will return the next prime number that can be found. Eventually this code will hit the maximum value for an integer and will go back to the beginning, but dealing with that is left as an exercise for the reader.&lt;/p&gt;</content>
		<summary>Warren Bates</summary>
	</entry>
	<entry>
		<link href="https://wbates.net/posts/theres-fast-code-and-theres-fast-code" />
		<id>https://wbates.net/posts/theres-fast-code-and-theres-fast-code</id>
		<title>There's fast code and there's fast code</title>
		<updated>2015-05-24T00:00:00Z</updated>
		<content>&lt;p&gt;I was solving a problem recently and came across a number of different ways of solving it. I decided to test them each out to see which was the quickest. The functions purpose was to return the number of digits in an integer. I've tried four different methods out. Two of them are single line solutions, one uses a bit of looping to solve the problem and the final one... well you'll see.&lt;/p&gt;
&lt;h1 id="log-method"&gt;Log Method&lt;/h1&gt;
&lt;p&gt;Logarithms return the power a number needs to be raised to in order to give that number. For example if our number is 1000. Log to the base 10 will return 3, because 1000 = 10^3. Any number up to 10000 will return a decimal value which rounds down to 3. e.g. log10(9999) = 3.99956568.... so we can use a combination of Math.Floor and Math.Log10 to give us the number of digits required. Our function should look something like this.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;private int IntegerLength_Log(int num)
{
    return (int)Math.Floor(Math.Log10(num) + 1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note: You need to add 1 to the return of the log value to get the number of digits.&lt;/p&gt;
&lt;h1 id="string-method"&gt;String method&lt;/h1&gt;
&lt;p&gt;This method relies on built in methods of converting the integer to a string and using the length property. This is probably the simplest and most versatile technique (it should handle negatives), but I was also convinced that because of the overhead associated with converting the integer to a string that this would be the least efficient method.&lt;/p&gt;
&lt;p&gt;The only code required is&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;private int IntegerLength_String(int num)
{
    return num.ToString().Length;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="looping-method"&gt;Looping method&lt;/h1&gt;
&lt;p&gt;This method loops, whilst increasing a variable's value by a power of 10 each cycle until that number is larger than the input.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;private int IntegerLength_Loop(int num)
{
    int length = 1;
    int comparator = 10;
    while (num &amp;gt; comparator) 
    {
        comparator *= 10;
        length++;
    }
    return length;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="if-statements"&gt;if statements&lt;/h1&gt;
&lt;p&gt;The final method is easily the lengthiest to write, and also one that as a problem solving mathematical type makes me cringe a little. There's no elegance to this solution, just a bit of brute force and lots of repetitive code. It requires using a series of if statements to check the integers value and return the length when we know what number it is less than. This is effectively the same as the above method but without the loop.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;private int IntegerLength_If(int num)
{
    if (num &amp;lt; 10)
    {
        return 1;
    }
    else if (num &amp;lt; 100)
    {
        return 2;
    }
    else if (num &amp;lt; 1000)
    {
        return 3;
    }
    else if (num &amp;lt; 10000)
    {
        return 4;
    }
    else if (num &amp;lt; 100000)
    {
        return 5;
    }
    else if (num &amp;lt; 1000000)
    {
        return 6;
    }
    else if (num &amp;lt; 10000000)
    {
        return 7;
    }
    else if (num &amp;lt; 100000000)
    {
        return 8;
    }
    else if (num &amp;lt; 1000000000)
    {
        return 9;
    }
    else
    {
        return 10;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If using a comparison like this on a BigInteger even more if statements would be required to cover up to the maximum value, but for C#'s int type this has us covered.&lt;/p&gt;
&lt;h1 id="timing"&gt;Timing&lt;/h1&gt;
&lt;p&gt;Each of these functions was then run using a for loop varying the input from 1'000 to 10'000'000 and the number of ticks taken to complete was recorded.&lt;/p&gt;
&lt;p&gt;The results are in: String method 2'937'886 ticks, Log Method 1'119'507, the Looping method 642'857 &amp;amp; the If method 437'401. The cringey set of if statements method is nearly 7 times faster than the string conversion method and 2.5 times faster than the log method.&lt;/p&gt;
&lt;p&gt;I think if this were for production code I'd probably use the looping method after changing it to handle integers of any type (i.e. BigInteger) and negative values because of the versatility and ease of rewriting should any problems be found, but this had definitely made me rethink some the assumptions I've built up over the years about how quickly code will run in comparison to how many lines of code there are.&lt;/p&gt;</content>
		<summary>Warren Bates</summary>
	</entry>
</feed>